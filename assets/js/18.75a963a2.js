(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{380:function(e,v,t){"use strict";t.r(v);var o=t(42),n=Object(o.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"看vue3源码时的意识流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#看vue3源码时的意识流"}},[e._v("#")]),e._v(" 看Vue3源码时的意识流")]),e._v(" "),t("p",[e._v("Vue2的时候, 创建vnode, 在代码中都是以render命名, 而patch能根据vnode渲染DOM.这个命名是有点奇怪的. 而Vue3将创建vnode以createVNode命名, 根据vnode渲染DOM的整个过程命名为render, 更加符合直觉.")]),e._v(" "),t("p",[e._v("Vue2中有"),t("code",[e._v("_vnode")]),e._v(", "),t("code",[e._v("$node")]),e._v("的命名, "),t("code",[e._v("_vnode")]),e._v("指组件template对应的vnode, 而$vnode指组件本身(Vue实例)对应的组件vnode, 除了组件vnode, 还有DOM元素对应的vnode.")]),e._v(" "),t("p",[e._v("Vue3一开始在"),t("code",[e._v("template")]),e._v("中是会自动对"),t("code",[e._v("ref")]),e._v("进行unwrap的, 从而避免手写"),t("code",[e._v(".value")]),e._v(", 其实现的方式是将我们"),t("code",[e._v("setup")]),e._v("返回的对象使用"),t("code",[e._v("reactive")]),e._v("处理, "),t("code",[e._v("reactive")]),e._v("之后的对象是可以unwrap的. 但是也存在着一些问题, 如果"),t("code",[e._v("setup")]),e._v("返回的是普通对象, 但是Vue内部使用"),t("code",[e._v("reactive")]),e._v("对其处理过后, "),t("code",[e._v("template")]),e._v("访问到的是Proxy对象, 产生了不一致. 因此Vue3调整了做法, 一个"),t("a",{attrs:{href:"https://github.com/vuejs/vue-next/pull/1682",target:"_blank",rel:"noopener noreferrer"}},[e._v("break change"),t("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=n.exports}}]);